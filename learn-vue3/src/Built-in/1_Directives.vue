<template>
	<div></div>
</template>
<!--  

  디렉티브

	-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

	v-text

		엘리먼트의 텍스트 컨텐츠를 업데이트한다.

		요구되는 값: String

		세부 사항

			v-text는 엘리먼트의 텍스트 컨텐츠 속성을 설정하므로, 엘리먼트 내부의 기존 컨텐츠를 덮어쓴다.
			텍스트 컨텐츠의 일부를 업데이트해야 하는 경우, 이중 중괄호를 사용해야 한다.

		예제

			<span v-text="msg"></span>
			//아래와 같음
			<span>{{msg}}</span>

		v-text 디렉티브는 HTML 요소의 텍스트 콘텐츠를 Vue 데이터의 값으로 설정하는 역할을 한다.

		일반적으로 Vue 템플릿에서는 데이터와 DOM 요소를 연결하기 위해 중괄호 보간법('{{}}')을 사용한다.
		하지만 v-text 디렉티브는 중괄호 보간법 대신 데이터를 DOM 요소의 텍스트로 직접 설정할 때 사용한다.

			<div v-text="message"></div>

		위의 예제에서 message는 Vue 컴포넌트의 데이터 속성으로 정의된 값이다. Vue는 v-text 디렉티브를 해석하고,
		해당 데이터 값인 message를 가져와 해당 요소의 텍스트의 내용으로 설정한다. 이후 'message'의 값이 변경되면 DOM요소의 텍스트도 자동으로 업데이트한다.

		v-text 디렉티브는 중괄호 보간법과 유사한 기능을 제공하지만, 특히 HTML이나 스크립트를 사용해야 하는 경우 사용할 수 있다.
		이 디렉티브를 사용하면 Vue의 XSS(Cross=Site Scripting)보호 기능을 이용할 수 있으므로, 안전한 텍스트 렌더링을 보장할 수 있따.

	-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

	v-html

		엘리먼트의 innerHTML을 업데이트한다.

		요구되는 값: String

		세부 사항

			v-html의 내용은 Vue 템플릿 문법을 처리하지 않고 일반 HTML로 삽입된다. 
			v-html을 사용하여 템플릿을 작성하려고 한다면, 이 방법 대신 컴포넌트를 사용하여 해결하는 방법을 고려해봐야 한다.

		- 보안 참고 사항
			웹사이트에서 임의의 HTML을 동적으로 렌더링하는 것은 XSS 공격으로 쉽게 이어질 수 있기 때문에 매우 위험할 수 있다.
			신뢰할 수 있는 컨텐츠에만 v-html을 사용하고, 사용자가 제공하는 컨텐츠에는 절대 사용하면 안된다.

		싱글 파일 컴포넌트(SFC)에서 scoped(범위를 지정한) Style은 v-html 내부 컨텐츠에 적용되지 않는다. 
		왜냐하면 해당 HTML은 Vue의 템플릿 컴파일러에서 처리되지 않기 때문이다.
		범위를 지정한 CSS로 v-html 컨텐츠를 대상으로 지정하려는 경우, CSS 모듈 또는 BEM과 같은 수동 범위 지정 방법과 함께 전역 <style> 엘리먼트를 사용할 수 있다.

		예제

			<div v-html="html"></div>

	-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

	v-show

		표현식의 truthy 값을 기반으로 엘리먼트의 가시성을 전환한다.

		요구되는 값: any

		세부 사항

			v-show는 인라인 스타일을 통해 display CSS 속성을 설정하며, 엘리먼트가 표시될 때 초기 display 값을 설정하려고 시도한다.
			또한 조건이 변경될 때 전환을 트리거한다.

		v-show 디렉티브는 조건에 따라 요소를 표시하거나 숨기는 데 사용된다.
		이 디렉티브는 렌더링 된 요소를 DOM에 직접 숨기거나 표시하는 것이 아니라 CSS의 display 속성을 토글하여 요소를 숨기거나 표시한다.

		v-show 디렉티브는 값이 참인 경우에는 요소를 표시하고, 가장 거짓인 경우에는 요소를 숨긴다.
		따라서 v-show에 전달되는 값이 true이면 요소가 화면에 표시되고, false이면 요소가 숨겨진다.

		다음은 v-show 디렉티브를 사용하는 간단한 얘제이다.

			<div v-show="isVisible">
				이 요소는 isVisible이 true일 때만 표시됩니다.
			</div>

		위의 코드에서 isVisible은 Vue 컴포넌트의 데이터 속성으로 정의된 값이다.
		따라서 isVaisible의 값이 true이면 요소가 화면에 표시되고 false이면 숨겨진다.

		v-show 디렉티브는 조건부로 요소를 표시하거나 숨기는 데 사용된다. 만약 일반 요소를 완전히 DOM에서 제거하고 싶다면 v-if 디렉티브를 사용해야 한다.

	-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

	v-if

		표현식의 truthy 값을 기반으로 엘리먼트 또는 템플릿 일부를 조건부로 렌더링한다.

		요구되는 값: any

		세부 사항

			v-if 엘리먼트가 토글되면, 엘리먼트와 여기에 포함된 디렉티브/컴포넌트가 파괴되고 재구성된다.
			초기 조건 값이 false이면, 내부 컨텐츠가 전혀 렌더링되지 않는다.

			텍스트 또는 여러 엘리먼트를 포함하는 조건부 블록을 나타내기 위해 <template>에 사용할 수도 있다.

			이 디렉티브는 조건이 변경될 때, 트렌지션을 트리거한다.

			v-for와 함께 사용하는 경우, v-if의 우선 순위가 높다. 하나의 엘리먼트에 이 두 디렉티브를 함께 사용하는 것은 권장되지 않는다.

	-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

	v-else

		v-if 또는 v-else-if 체인에 대한 else이다.

		표현식을 허용하지 않는다.

		세부 사항

			제한사항: 이전 형제 엘리먼트에 v-if 또는 v-else-if가 있어야 한다.

			<template>에서 텍스트 또는 여러 엘리먼트를 포함하는 조건부 블록을 나타내는 데 사용할 수 있다.

		예제

			<div v-if="Math.random() > 0.5">
				이제 나를 볼 수 있어요!
			</div>
			<div v-else>
				아직이에요!
			</div>

	-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

	v-else-if

		v-if에 대한 else if 블록을 나타낸다. v-else-if는 계속 이어서 사용할 수 있다.

		요구되는 값: any

		세부 사항

			제한사항: 이전 형제 엘리먼트에 v-if 또는 v-else-if가 있어야 한다.

			<template>에서 텍스트 또는 여러 엘리먼트를 포함하는 조건부 블록을 나타내는 데 사용할 수 있다.

		예제

			<div v-if="type === 'A'">
				A
			</div>
			<div v-else-if="type === 'B'">
				B
			</div>
			<div v-else-if="type === 'C'">
				C
			</div>
			<div v-else>
				A/B/C 가 아니야!
			</div>

	-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

	v-for

		소스 데이터를 기반으로 엘리먼트 또는 템플릿 블록을 여러 번 렌더링한다.

		요구되는 값: Array | Object | number | String | Iterable

		세부 사항

			디렉티브는 반복되는 과정의 현재 값에 별칭을 제공하기 위해, 특수 문법인 alias in expression(표현식 내 별칭)을 사용해야 한다.

				<div v-for="item in items">
					{{ item.text }}
				</div>

			또한 인덱스(객체에서 사용되는 경우 키)의 별칭을 지정할 수도 있다.

				<div v-for="(item, index) in items"></div>
				<div v-for="(value, key) in object"></div>
				<div v-for="(value, name, index) in object"></div>

			v-for의 기본 동작은 엘리먼트를 이동하지 않고 제자리에 패치(patch)하려고 한다.
			강제로 엘리먼트를 재정렬하려면, 특수 속성 key를 사용하여 순서 지정을 위한 힌트를 제공해야한다.

				<div v-for="item in items" :key="item.id">
					{{ item.text }}
				</div>

			v-for는 네이티브 Map, Set과 더불어 Iterable Protocol을 구현한 값에서도 작동한다.

	-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

	v-on

		엘리먼트에 이벤트 리스너를 연결한다.

		단축 문법: @

		요구되는 값: Function | Inline Statement | Object (without argument)

		인자 event (선택사항: 객체 문법을 사용하는 경우)

		수식어:

			- .stop: event.stopPropaagtion() 호출.
			- .prevent: event.preventDefault() 호출.
			- .capture: 캡처 모드로 이벤트 등록.
			- .self: 이벤트가 이 엘리먼트에서 전달된 경우에만 트리거 됨.
			- .{keyAlias}: 이벤트가 특정 키에 대해서만 트리거 됨.
			- .once: 이벤트가 한 번만 트리거 됨(일회용 처럼).
			- .left: 마우스 왼쪽 버튼으로만 이벤트가 트리거 됨.
			- .right: 마우스 오른쪽 버튼으로만 이벤트가 트리거 됨.
			- .middle: 마우스 중앙(힐 클릭) 버튼으로만 이벤트가 트리거 됨.
			- .passive: { passive: true } 옵션으로 DOM 이벤트를 등록

		세부 사항

			이벤트 타입은 인자로 표시된다. 표현식은 메서드 이름 또는 인라인 명령문이거나, 수식어가 있는 경우 생략될 수 있다.

			일반 엘리먼트에 사용되면 네이티브 DOM 이벤트만 수신한다. 
			커스텀 엘리먼트 컴포넌트에서 사용되는 경우, 해당 자식 컴포넌트에서 발송(emit)하는 커스텀 이벤트를 수신한다.

			네이티브 DOM 이벤트를 수신할 때, 메서드의 인자는 네이비트 이벤트 분이다.
			인라인 명령문을 사용하는 경우, 명령문은 특수 속성인 $event로 v-on:click="handle('ok', $event)"와 같이 이벤트 객체에 접근할 수 있다.

			v-on은 인자 없이 이벤트(키): 리스터(값) 형식의 객체 바인딩도 지원한다.
			수식어는 객체 문법을 사용할 때는 지원하지 않는다.

		예제

			메서드 핸들러
			<button v-on:click="doThis"></button>

			동적 이벤트
			<button v-on:[event]="doThis"></button>

			인라인 표현식
			<button v-on:click="doThat('hello', $event)"></button>

			단축 문법
			<button @click="doThis"></button>

			단축 문법 동적 이벤트
			<button @[event]="doThis"></button>

			전파 중지
			<button @click.stop="doThis"></button>

			event.preventDefault() 작동
			<button @click.prevent="doThis"></button>

			표현식 없이 event.preventDefault()만 사용
			<form @submit.prevent></form>

			수식어 이어서 사용
			<button @click.stop.prevent="doThis"></button>

			키 별칭을 수식어로 사용
			<input @keyup.enter="onEnter" />

			클릭 이벤트 단 한 번만 트리거
			<button v-on:click.once="doThis"></button>

			객체 문법
			<button v-on="{ mousedown: doThis, mouseup: doThat }"></button>

		자식 컴포너트의 커스텀 이벤트 수신 대기"my-event"가 발생하면 핸들러가 호출됨

			<MyComponent @my-event="handleThis" />

			인라인 표현식
			<MyComponent @my-event="handleThis(123, $event)" />

	-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

	v-bind

		하나 이상의 속성 또는 컴포넌트 prop을 표현식에 동적으로 바인딩한다.

		단축 문법

			: 또는 .(.prop 수식어를 사용할 때)

			속성(attribute)과 바인딩된 값이 같은 이름을 가질 경우 값을 생략할 수 있음(3.4)

		요구되는 값

			any(인자 있음) | Object(인자 있음)

		인자: attrOrProp(optional)

		수식어

			- .camel: kebab-case 속성 이름을 camelCase로 변화
			- .prop: 바인딩을 DOM 속성(property: 이하 프로퍼티) 으로 강제 설정(3.2)
			- .attr: 바인딩을 DOM 속성(attribute)으로 강제 설정

		사용법

			class 또는 Style 속성을 바인딩하는 데 사용되는 경우, v-bind는 배열 또는 객체와 같이 값을 추가할 수 있는 자세한 타입을 지원한다.

			엘리먼트에 바인딩을 설정할 때, Vue는 기본적으로 연산자 검사흘 위한 in을 사용하여, 엘리먼트에 프로퍼티로 정의된 키가 있는지 확인한다.
			프로퍼티가 정의되면, Vue는 속성 대신 DOM 프로퍼티로 값을 설정한다. 이것은 대부분의 경우 작동하지만, .prop 또는 .attr 수식어를 명시적으로 사용하여 이 동작을 재정의할 수 있다.
			이것은 특히 커스텀 엘리먼트로 작업할 때 필요하다.

			컴포넌트 prop 바인딩에 사용될 때 prop은 자식 컴포넌트에서 적절하게 선언되어야 한다.
			
			인자 없이 사용하는 경우, 속성을 이름-값 쌍으로 포함하는 객체를 바인딩하는 데 사용할 수 있다.
			이 모드에서  class와 style은 배열 또는 객체를 지원하지 않는다.

		예제

			속성 바인딩
			<img v-bind:src="imageSrc" />

			동적인 속성명
			<button v-bind:[key]="value"></button>

			단축 문법
			<img :src="imageSrc" />

			같은 이름 생략 가능 (3.4+), 오른쪽과 같음 :src="src"
			<img :src />

			단축 문법과 동적 속성명
			<button :[key]="value"></button>

			인라인으로 문자열 결합
			<img :src="'/path/to/images/' + fileName" />

			class 바인딩
			<div :class="{ red: isRed }"></div>
			<div :class="[classA, classB]"></div>
			<div :class="[classA, { classB: isB, classC: isC }]"></div>

			style 바인딩
			<div :style="{ fontSize: size + 'px' }"></div>
			<div :style="[styleObjectA, styleObjectB]"></div>

			속성을 객체로 바인딩
			<div v-bind="{ id: someProp, 'other-attr': otherProp }"></div>

			prop 바인딩. "prop"은 자식 컴포넌트에서 선언되어 있어야 함
			<MyComponent :prop="someThing" />

			자식 컴포넌트와 공유될 부모 props를 전달
			<MyComponent v-bind="$props" />

			XLink
			<svg><a :xlink:special="foo"></a></svg>

		.prop 수식어에는 전용 단축 문법 . 이 있다.

			<div :someProperty.prop="someObject"></div>

			위 코드는 아래와 같이 단축할 수 있음
			<div .someProperty="someObject"></div>

		.camel 수식어는 DOM 내 템플릿을 사용할 때, v-bind의 속성명을 카멜라이징(camelizing)할 수 있다.
		예를 들면, SVG viewBox 속성

			<svg :view-box.camel="viewBox"></svg>

		문자열 템플릿을 사용하거나 템플릿을 빌드 과정으로 미리 컴파일하는 경우에는 .camel이 필요하지 않는다.

		바인딩 사용 예시

		1. 속성 동적 바인딩
			HTML 요소의 속성을 Vue 인스턴스의 데이터와 동적으로 바인딩할 때 사용된다.
			예를 들어, 버튼의 disabled 속성을 사용자의 로그인 상태에 따라 동적으로 설정하거나 해제하는 경우에 많이 사용한다.
			
				<button v-bind:disabled="isLoggedIn">로그인</button>

		2. 클래스와 스타일 바인딩
			HTML 요소의 클래스 및 스타일을 동적으로 변경할 때 사용된다. 조건부로 클래스를 추가하거나 제거하거나, 스타일 속성을 변경할 수 있다.

				<div v-bind:class="{ active: isActive, 'text-danger': hasError }"></div>
				<div v-bind:style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>

		3. 동적 속성 바인딩
			특정 이벤트가 발생할 때 속성을 동적으로 설정하고자 할 때 사용된다. 
			예를 들어, 마우스 오버 이벤트가 발생할 때 이미지의 src 속성을 변경하는 경우 등에 활용할 수 있다.

				<img v-bind:src="isMouseOver ? hoverImageUrl : defaultImageUrl" />

		4. 컴포넌트와 데이터 바인딩
			사용자 정의 Vue 컴포넌트의 속성에 데이터를 전달할 때 사용된다. 
			이를 통해 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달하거나, 자식 컴포넌트의 속성을 동적으로 업데이트할 수 있다.

				<my-component v-bind:propName="parentData"></my-component>

	-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

	v-model

		사용자 입력을 받는 폼(form) 에리먼트 또는 컴포넌트에 양방향 바인딩을 만든다.

		요구되는 값: 사용자 입력을 받는 폼 엘리먼트 또는 컴포넌트의 출력 값에 따라 다름.

		다음으로 제한됨

		- <input>
		- <select>
		- <textarea>
		- 컴포넌트

		수식어

		- .lazy: input 대신 change 이벤트를 수신함.
		- .number: 유효한 입력 문자열을 숫자로 변환하여 전달.
		- .trim: 사용자 입력의 공백을 트리밍.

	-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

	v-slot

		v-slot은 이름이 있는 슬롯이거나 props를 받을 것으로 예상되는 범위형(Scoped)슬롯을 나타낸다.
		이를 통해 Vue.js에서 컴포넌트의 슬롯을 정의할 때 사용된다.

		단축 문법: #

		v-slot 디렉티브는 주로 컴포넌트의 일부로 사용된다. 이름이 있는 슬롯을 정의하려면 해당 슬롯의 이름을 지정하고 그 안에 컨텐츠를 작성한다.
		예를 들어, <tempalte v-slot:header>는 이름이 있는 슬롯인 header를 정의하고 해당 슬롯의 컨텐츠를 작성한다.

		props를 받을 것으로 예성되는 범위형(Scoped)슬롯을 사용할 때는 해당 슬롯에서 props를 받을 변수를 선언한다.
		이때 v-slot의 인자로는 해당 변수를 받을 이름을 지정한다. 그리고 해당 슬롯의 컨텐츠에서 이 변수를 사용하여 props의 값을 참조할 수 있다.

		예를 들어, <template v-slot:item="slotProps">에서 item은 props를 받을 것으로 예상되는 범위형 슬롯이고, slotProps는 이 슬롯에서 받을 props를 담을 변수이다.
		이후 컨텐츠 내에서 slotProps 변수를 사용하여 props의 값을 참조할 수 있다.

	-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

	v-pre

		이 엘리먼트와 모든 자식 엘리먼트의 컴파일을 생략한다.

		표현식을 허용하지 않는다.

		세부 사항

			v-pre가 있는 엘리먼트 내에서 모든 Vue 템플릿 구문은 그대로 유지되고 렌더링된다.
			가장 일반적인 사용 사례는 이중 중괄호 태그를 표시하는 것이다.

		예제

			<span v-pre>{{ 이곳은 컴파일되지 않습니다. }}</span>

		v-pre 디렉티브는 Vue.js가 컴파일할 때 템플릿을 건너뛰도록 지시한다. 이 디렉티브가 적용된 엘리먼트와 그 안의 모든 자식 엘리먼트는 Vue 컴파일러에 의해 변경되지 않는다.
		이는 일반적으로 Vue 템플릿에서 사용되는 데이터 바인딩, 디렉티브 및 기타 Vue 특정 문법을 사용하지 않고 순수한 HTML을 표시해야 하는 경우에 유용하다.

		예를 들어, 서버에서 이미 Vue 컴포넌트를 렌더링하고 클라이언트에서 재사용하는 경우 렌더링 속도를 향상시키기 위해 v-pre를 사용할 수 있다.
		또한 특정 HTML 블록을 Vue 컴파일러가 처리하지 않도록 하고 싶을 때도 v-pre를 사용할 수 있다.

	-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

	v-once

		엘리먼트와 컴포넌트를 한 번만 렌더링하고, 향후 업데이트를 생략한다.

		표현식을 허용하지 않는다.

		세부 사항

			이후 다시 렌더링할 때 엘리먼트/컴포넌트 및 모든 자식들은 정적 컨텐츠로 처리되어 생략된다.
			이것은 업데이트 성능을 최적화하는 데사용할 수 있다.

				//단일 엘리먼트
				<span v-once>절대 바뀌지 않음: {{msg}}</span>
				//자식이 있는 엘리먼트
				<div v-once>
					<h1>댓글</h1>
					<p>{{msg}}</p>
				</div>
				//컴포넌트
				<MyComponent v-once :comment="msg"></MyComponent>
				//`v-for` 디렉티브
				<ul>
					<li v-for="i in list" v-once>{{i}}</li>
				</ul>

	-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

	v-memo (3.2)

		요구되는 값: any[]

		세부 사항

			템플릿 하위 트리를 메모한다. 엘리먼트와 컴포넌트 모두에 사용할 수 있다.
			디렉티브는 메모이제이션을 위해 비교할 의존성 값의 고정된 길이의 배열을 요구한다.
			배열의 모든 값이 마지막 렌더링과 같으면 전체 하위 트리에 대한 업데이트를 생략한다.
			예를 들어,

				<div v-memo="[valueA, valueB]">
					...
				</div>

			컴포넌트가 다시 렌더링될 때 valueA와 valueB가 모두 동일하게 유지되면, 이 <div>와 하위 항목에 대한 모든 업데이트를 생략한다.
			사실, 하위 트리의 메모된 복사본을 재사용할 수 있기 때문에 가상 DOM VNode 생성도 생략한다.

			메모제이션 배열을 올바르게 지정하는 것이 중요하다. 그렇지 않으면 실제로 적용되어야하는 업데이트를 건너뛸 수 있다.
			빈 의존성 배열(v-memo="[]")이 있는 v-memo는 기능적으로 v-once와 동일하다.

		v-for와 함께 사용하기

			v-memo는 성능이 중요한 시나리어에서 마이크로 최적화를 위해 제공되는 것으로, 일반적으로 거의 필요하지 않다.
			이것이 동움이 될 수 있는 가장 일반적인 경우는 큰 리스트(length > 1000)를 v-for로 렌더링할 때이다.

				<div v-for="item in list" :key="item.id" v-memo="[item.id === selected]">
					<p>ID: {{ item.id }} - 선택됨: {{ item.id === selected }}</p>
					<p>...더 많은 자식 노드</p>
				</div>

			컴포넌트의 selected 상태가 변경되면, 대부분의 아이템이 정확히 동일하게 유지되더라도 많은 양의 VNode가 생성된다.
			여기서 v-memo 사용법은 본질적으로 "아이템의 선택여부가 바뀐 경우에만, 이 아이템을 업데이트하십시오"이다.
			이렇게 하면 영향을 받지 않는 모든 아이템이 이전 VNode를 재사용하고, 차이점 비교를 생략할 수 있다.
			Vue는 아이템의 :key로 자동 추론하므로, 메모 의존성 배열에 item.id를 포함할 필요가 없다.

				경고
					v-for와 함께 v-memo를 사용할 때, 동일한 엘리먼트에 사용되는지 확인이 필요하다.
					v-memo는 v-for 내에서 작동하지 않는다.

				v-memo는 자식 컴포넌트 업데이트 확인이 최적화되지 않는 특정 엣지 케이스에서 원치않는 업데이트를 수동으로 방지하기 위해 컴포넌트에 사용할 수도 있다.
				그러나 필요한 업데이트를 건너뛰지 않도록 올바른 의존성 배열을 지정하는 것은 개발자의 책임이다.

	-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

	v-cloak

		준비될 때까지 컴파일되지 않은 템플릿을 숨기는 데 사용된다.

		표현식을 허용하지 않는다.

		세부 사항

			이 디렉티브는 빌드 과정에서 없는 설정에서만 필요하다.

			DOM 내 템플릿을 사용할 때, "컴파일되지 않은 템플릿이 순간 보이는 현상"이 있을 수 있다.
			이러면 사용자는 컴포넌트가 렌더링된 컨텐츠로 대체할 때까지 이중 중괄호 태그를 볼 수 있다.

			v-cloak은 연결된 컴포넌트 인스턴스가 마운트될 때까지 엘리먼트에 남아 있다.
			[v-cloak] {display:none}과 같은 CSS 규칙과 결합하여, 컴포넌트가 준비될 때까지 템플릿을 숨기는 데 사용할 수 있다.

		예제

		//css
			[v-cloak] {
				display: none;
			}

		//template
			<div v-cloak>
				{{ message }}
			</div>

		<div>는 컴파일이 완료될 때까지 표시되지 않는다.







-->
<script>
export default {
	setup() {
		return {};
	},
};
</script>

<style lang="scss" scoped></style>
