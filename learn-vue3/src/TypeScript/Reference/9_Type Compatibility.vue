<template>
	<div></div>
</template>
<!--  

  타입 호환성(Type Compatibility)

    TypeScript의 타입 호환성은 구조적 서브 타이핑(subtyping)을 기반으로 한다.
    구조적 타이핑이란 오직 멤버만으로 타입을 관계시키는 방식이다.
    명목적 타이핑(nominal typing)과는 대조적이다.

      interface Named {
        name: string;
      }

      class Person {
        name: string;
      }

      let p: Named;
      // 성공, 구조적 타이핑이기 때문이다.
      p = new Person();

    C#이나 Java와 같은 명목적타입 언어에서는 Person 클래스는 Named 인터페이스를 명시적인 구현체로 기술하지 않았기 때문에 해당 코드는 오류를 발생시킨다.

    TypeScript의 구조적 타입 시스템은 JavaScript 코드의 일반적인 작성 방식에 따라서 설계되었다. 
    JavaScript는 함수 표현식이나 객체 리터럴 같은 익명 객체를 광범위하게 사용하기 때문에 
    JavaScript에서 발견되는 관계의 타입을 명목적 타입 시스템보다는 구조적 타입 시스템을 이용하여 표현하는 것이 훨씬 더 자연스럽다.


  건전성에 대한 참고사항 (A Note on Soundness)

    TypeScript의 타입 시스템은 컴파일 시간에 확인할 수 없는 특정 작업을 안전하게 수행할 수 있다.
    타입 시스템이 이런 특성을 갖고 있을 때, "건전"하지 않다고 말한다.

    TypeScript에서 건전성에 대한 참고사항은 타입 시스템이 얼마나 신뢰할 수 있는지, 즉 타입 검사가 코드의 안정성을 얼마나 보장하는지에 관한 주제이다.
    이는 일반적으로 "타입 안전성(Type Soundness)"이라고도 한다.

    타입스크립트의 타입 시스템은 정적 타입 검사를 통해 코드의 일부 에러를 미리 발견할 수 있도록 도와준다.
    이를 통해 프로그래머가 런타임 중에 발생할 수 있는 타입 관련 에러를 사전에 방지할 수 있다.
    그러나 타입스크립트는 완벽하지 않다. 몇 가지 상황에서는 타입스크립트가 타입 에러를 감지하지 못 할 수 있다.

    이에 대한 한 가지 예시는 타입 단언(Type Assertion)이다. 타입 단언은 개발자가 "이 변수는 이 타입이다"라고 명시적으로 선언하는 것이다.
    이 경우, 개발자가 실제 타입과 다른 타입을 단언할 수 있으며, 이는 런타임 에러를 발생시킬 수 있다.

    또 다른 예시는 동적인 타입 변환(Dynamic Type Casting)이다. 이는 TypeScript가 타입 정보를 잃어버리거나 외부에서 주입되는 데이터에 의해 타입이 결정될 때 발생할 수 있다.
    이러한 상황에서는 타입스크립트가 타입 에러를 발견하지 못할 수 있으며, 이는 런타임 에러의 가능성을 남겨둘 수 있다.

    이러한 이유로, 타입스크립트에서 건전성에 대한 참고사항은 "타입 시스템은 코드의 안전성을 향상시키지만, 완벽한 보장은 아니다."라는 것이다.
    따라서 프로그래머는 여전히 코드를 신중하게 작성하고, 타입에러를 최소화하기 위해 노력해야 한다.


  시작하기

    타입스크립트의 구조적 타입 시스템의 기본 규칙은 y가 최소한 x와 동일한 멤버를 가지고 있다면 x와 y는 호환된다는 것이다.

      interface Named {
        name: string;
      }

      let x: Named;
      // y의 추론된 타입은 { name: string; location: string } 이다.
      let y = { name: "Alice", location: "Seattle" };
      x = y;

    y를 x에 할당할 수 있는지 검사하기 위해, 컴파일러는 x의 각 프로퍼티를 검사하여 y에서 상응하는 호환 가능한 프로퍼티를 찾는다.
    이 경우, y는 name이라는 문자열 멤버를 가지고 있어야 한다. 그러므로 할당이 허용된다.

    함수 호출 인수를 검사할 때 동일한 할당 규칙이 적용된다.

      function greet(n: Named) {
        console.log("Hello, " + n.name);
      }
      greet(y); // 성공

    y는 location 프로퍼티를 추가적으로 가지고 있지만 오류를 발생시키지 않는 점에 유의한다. 
    호환성을 검사할 때는 오직 대상 타입의 멤버(이 경우는 Named)만 고려한다.

    이 비교하는 과정은 재귀적으로 각 멤버와 하위-멤버의 타입을 탐색하면서 진행된다.


  두 함수 비교 (Comparing two functions)

    원시 타입과 객체 타입을 비교하는 것은 비교적 간단하지만, 어떤 유형의 함수들이 호환될 수 있는지에 대한 질문은 조금 더 복잡하다.
    먼저 매개변수 목록에서만 다른 두 함수의 기본 예제를 살펴보자.

      let x = (a: number) => 0;
      let y = (b: number, s: string) => 0;

      y = x; // 성공
      x = y; // 오류

    x를 y에 할당할 수 있는지 검사하기 위해, 먼저 매개변수 목록을 살펴보자. 
    x의 각 매개변수는 호환 가능한 타입을 가진 y의 해당 매개변수를 가져야 한다.
    매개변수의 이름은 고려하지 않고 타입만 검사한다는 점에 유의하자. 
    이 경우에는 x의 모든 매개변수는 y에 상응하는 호환 가능한 매개변수를 가지므로 할당이 허용된다.

    두 번째 할당은 y는 x에 없는 두 번째 필수적인 매개변수를 가지고 있기 때문에 할당이 허용되지 않아 오류가 발생한다.

    y = x의 예제에서처럼 매개변수를 "버리는"것이 허용되는 이유가 궁금할 수 있다. 
    이러한 할당이 허용되는 이유는 함수의 추가 매개변수를 무시하는 것이 실제로 JavaScript에선 매우 일반적이기 때문이다.
    예를 들어, Array#forEach는 콜백 함수에게 3 가지 매개변수인 배열 요소, 그 요소의 인덱스 그리고 이것을 포함하는 배열을 제공한다.
    그럼에도 불구하고 첫 번째 매개변수만 사용하는 콜백을 제공하는 것은 매우 유용하다.

      let items = [1, 2, 3];

      // 추가 매개변수를 강제로 사용하지 말자.
      items.forEach((item, index, array) => console.log(item));

      items.forEach(item => console.log(item));

    반환 타입이 다른 두 함수를 사용하여 반환 타입이 어떻게 처리되는지 살펴보자.

      let x = () => ({name: "Alice"});
      let y = () => ({name: "Alice", location: "Seattle"});

      x = y; // 성공
      y = x; // 오류, x()는 location 프로퍼티가 없다.

    타입 시스템은 원본 함수의 반환 타입이 대상 타입의 반환 타입의 하위 타입이 되도록 한다.


  함수 매개변수의 Bivariance

    함수 매개변수의 Bivariance란 TypeScript에서 함수타입의 매개변수가 공변성과 반공변성의 특징을 모두 가질 때 발생하는 현상을 의미한다.
    이것은 TypeScript의 타입 시스템에서 발생하는 한 가지 특이한 상황이다.

    공변성은 서브 타입이 수퍼 타입으로 할당 가능한 것을 말한다. 즉, 보다 구체적인 타입은 보다 일반적인 타입에 할당될 수 있다.
    그래서 함수 매개변수에서 공변성이 적용되면, 매개변수 타입이 너무 느슨하게 적용될 수 있어서 함수의 안정성을 악화시킬 수 있다.

    반공변성은 반대로 수퍼 타입이 서브 타입으로 할당될 수 없는 것을 말한다.
    즉, 보다 일반적인 타입은 보다 구체적인 타입에 할당될 수 없다. 이 경우에도 함수 매개변수의 반공변성이 적용되면 매개변수 타입이 너무 제한적으로 적용되어 함수의 유연성이 저하될 수 있다.

    Bivariance는 이 두가지 특성을 모두 갖는 현상을 나타낸다. 즉, 함수 타입의 매개변수가 공변성과 반공변성을 동시에 가질 때 발생한다.
    이것은 일반적으로 TypeScript의 특정 사용 사례에서 문제가 발생할 수 있음을 의미한다. 함수 매개변수의 타입을 Bivariance로 선언하면 타입 시스템이 더욱 유연해지지만, 그만큼 코드 안정성이 약화될 수 있다.

    이러한 이유로, TypeScript는 일반적으로 Bivariance를 허용하지 않으며, 이에 대한 경고를 표시한다.
    대신, TypeScript에서는 함수 매개변수의 타입을 명시적으로 공변성 또는 반공변성으로 지정하는 것이 좋다.
    이를 통해 코드의 안전성을 유지하면서도 필요에 맞는 유연성을 확보할 수 있다.


  선택적 매개변수와 나머지 매개변수

    1. 선택적 매개변수(Optional Parameters)
      선택적 매개변수는 함수 호출 시 값을 제공하지 않아도 되는 매개변수이다. TypeScript에서는 선택적 매개변수를 정의할 때 매개변수 이름 뒤에 물음표(?)를 붙인다.
      이를 통해 함수를 호출할 때 해당 매개변수에 값을 전달하지 않을 수 있다.
      선택적 매개변수가 지정되지 않은 경우 해당 매개변수는 undefined로 설정된다. 예를 들어,

        function greet(name?: string) {
          if (name) {
            console.log(`Hello, ${name}!`);
          } else {
            console.log("Hello, anonymous!");
          }
        }

        greet(); // 출력: "Hello, anonymous!"
        greet("Alice"); // 출력: "Hello, Alice!"

    2. 나머지 매개변수(Rest Parameters)
      나머지 매개변수는 함수 정의 시에 일부 매개변수의 수가 불명확하거나 가변적일 때 사용된다. TypeScirpt에서는 매개변수 이름 앞에 세 개의 점('...')을 붙여 나머지 매개변수를 정의 한다.
      이를 통해 함수에 여러 개의 인자를 전달하고, 해당 매개변수를 배열로 받을 수 있다. 예를 들어,

        function sum(...numbers: number[]) {
          let total = 0;
          for (const num of numbers) {
              total += num;
          }
          return total;
        }

        console.log(sum(1, 2, 3)); // 출력: 6
        console.log(sum(10, 20, 30, 40)); // 출력: 100

      선택적 매개변수와 나머지 매개변수는 TypeScript에서 함수를 더 유연하고 다양한 상황에 대응할 수 있도록 도와준다.
      선택적 매개변수를 사용하여 함수를 호출하는 코드를 간소화하고, 나머지 매개변수를 사용하여 가변적 매개변수의 수를 처리할 수 있다.
      함께 사용할 때 이 두가지 매개변수 유형은 매우 유용하다.


  오버로드 함수

    함수에 오버로드가 있는 경우 원본 타입의 각 오버로드는 대상 타입의 호환 가능한 시그니처와 일치해야 한다.
    이를 통해 원본 함수와 모든 동일한 상황에서 대상 함수를 호출할 수 있다.


  열거형

    열거형은 숫자와 호완되며 숫자는 열거형과 호환된다. 다른 열거형 타입의 열거형 값은 호환되지 않는 것으로 간주된다.
    예를 들어,

      enum Status {
        Ready,
        Waiting,
      }
      enum Color {
        Red,
        Blue,
        Green,
      }

      let status = Status.Ready;
      status = Color.Green; // 오류


  클래스

    클래스는 객체 리터럴 타입과 인터페이스와 한 가지 예외를 제외하곤 유사하게 동작한다.
    클래스는 정적 타입과 인스턴스 타입이 있다. 클래스 타입의 두 개의 객체를 비교할 때, 오직 인스턴스의 멤버만 비교된다.
    정적인 멤버와 생성자는 호환성에 영향을 주지 않는다.

      class Animal {
        feet: number;
        constructor(name: string, numFeet: number) {}
      }

      class Size {
        feet: number;
        constructor(numFeet: number) {}
      }

      let a: Animal;
      let s: Size;

      a = s; // 성공
      s = a; // 성공


  클래스의 private 멤버와 protected 멤버

    클래스의 private와 protected 멤버는 호환성에 영향을 준다. 클래스 인스턴스의 호환성을 검사할 때 대상 타입에 private 멤버가 있다면, 원본 타입 또한 동일 클래스에서 비롯된 private 멤버가 있어야 한다.
    마찬가지로 protected 멤버가 있는 인스턴스도 똑같이 적용된다. 이를 통해 클래스는 상위 클래스와 호환 가능하지만 같은 형태를 가진 다른 상속 계층 구조의 클래스와는 호환되지 않는다.


  제네릭

    TypeScript는 구조적 타입 시스템이기 때문에, 타입 매개변수는 멤버의 타입의 일부로 사용할 때 결과 타입에만 영향을 준다. 예를 들어,

      interface Empty<T> {}
      let x: Empty<number>;
      let y: Empty<string>;

      x = y; // 성공, y는 x의 구조와 대응하기 때문

    위에서 x와 y는 구조가 타입 인수를 서로 다르게 사용하지 않기 때문에 호환된다. 이 예제에서 Empty<T>를 멤버에 추가한다면

      interface NotEmpty<T> {
        data: T;
      }
      let x: NotEmpty<number>;
      let y: NotEmpty<string>;

      x = y; // 오류, x와 y는 호환되지 않음

    이런 식으로, 타입 인수가 이정된 제네릭 타입은 비-제네릭 타입처럼 동작한다.

    타입 인수가 지정되지 않은 제네릭 타입에 관해선, 모든 지정되지 않은 타입 인수를 대신해서 any로 지정함으로써 호환성 검사를 한다.
    그 결과 생성된 타입은 비-제네릭 경우와 마찬가지로 호환성을 검사한다.

    예를 들어,

      let identity = function <T>(x: T): T {
        // ...
      };
      let reverse = function <U>(y: U): U {
        // ...
      };
      identity = reverse; // 성공, (x: any) => any는  (y: any) => any와 대응하기 때문

-->
<script>
export default {
	setup() {
		return {};
	},
};
</script>

<style lang="scss" scoped></style>
