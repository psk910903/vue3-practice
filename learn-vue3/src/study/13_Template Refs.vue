<template>
	<div></div>
</template>
<!--  
  
  템플릿 참조

    Vue의 선언적 렌더링 모델은 개발자가 직접 DOM에 접근해야 해야하는 대부분을 추상화하지만,
    개발자가 DOM 엘리먼트에 직접 접근해야 하는 경우가 여전히 있을 수 있다.
    이러한 필요성을 충족시키기 위해 ref라는 특별한 속성을 사용할 수 있다.

      <input ref="input">

    ref는 v-for 장에서 언급한 key 속성과 유사한 특수 속성이다. 이를 통해 마운트된 특정 DOM 엘리먼트 또는 자식 컴포넌트 인스턴스에 직접적인 참조를 얻을 수 있다.
    예를 들어 컴포넌트 마운트의 인풋에 초점을 맞추거나 엘리먼트에서 타사 라이브러리를 초기화하려는 경우, 프로그래밍 방식으로 조작하기 편리하다.

  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    ref로 접근하기

      Composition API를 사용하여 참조를 얻으려면, 템플릿 ref 속성 값과 일지하는 이름으로 ref를 선언해야 한다.

        <script setup>
        import { ref, onMounted } from 'vue'

        // 엘리먼트 참조를 위해 ref를 선언
        // 이름은 템플릿 ref 값과 일치해야 한다.
        const input = ref(null)

        onMounted(() => {
          input.value.focus()
        })
        </script>

        <template>
          <input ref="input" />
        </template>

      <script setup>을 사용하지 않는 경우, setup()에서 참조를 반환해야 한다.

        export default {
          setup() {
            const input = ref(null)
            // ...
            return {
              input
            }
          }
        }

      컴포넌트가 마운트된 이후에만 ref에 접근할 수 있다. 템플릿 표현식에서 input에 접근하려고 하면, 첫 번째 렌더링에서는 null이 된다.
      이는 요소가 첫 번째 렌더링 이후에야 존재하기 때문이다.

      템플릿 ref의 변경 사항을 감시하려는 경우 ref에 null 값이 있는 경우를 고려해야 한다.

        watchEffect(() => {
          if (input.value) {
            input.value.focus()
          }else {
            // v-if에 의해 아직 마운트 되지 않았거나, 마운트 해제된 경우
          }
        })

  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    v-for 내부에서 ref 사용하기(버전이 v3.2.25 이상)

      ref가 v-for 내부에서 사용되면, 해당 ref는 마운트 후 엘리먼트로 채워지므로 배열 값이어야 한다.

        <script setup>
        import { ref, onMounted } from 'vue'

        const list = ref([])

        const itemRefs = ref([])

        onMounted(() => console.log(itemRefs.value))
        </script>

        <template>
          <ul>
            <li v-for="item in list" ref="itemRefs">
              {{ item }}
            </li>
          </ul>
        </template>

      ref 배열은 소스 배열과 동일한 순서를 보장하지 않는다.

  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    함수로 참조하기

      문자열 키 대신 ref 속성을 함수에 바인딩 할 수도 있다. 
      이함수는 각 컴포넌트 업데이트시 호출되며, 엘리먼트 참조를 저장할 위치에 대한 완전한 유연성을 제공한다.
      이 함수는 첫 번째 인자로 엘리먼트 참조를 받는다.

        <input :ref="(el) => { el을 속성이나 ref에 할당 }"

      :ref와 같이 동적 바인딩으로 사용하는 경우에는 ref의 이름 대신 함수를 전달할 수 있다.
      엘리먼트가 마운트 해제되는 경우 인자는 null이다.
      물론 인라인 함수 대신 메서드를 사용할 수 있다.

  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    컴포넌트에 ref 사용하기

      ref는 자식 컴포넌트에 사용할 수도 있다. 이 경우 ref는 컴포넌트 인스턴스를 참조한다.

        <script setup>
        import { ref, onMounted } from 'vue'
        import Child from './Child.vue'

        const child = ref(null)

        onMounted(() => {
          // child.value는 <Child />의 인스턴스를 가집니다.
        })
        </script>

        <template>
          <Child ref="child" />
        </template>

      자식 컴포넌트가 옵션 API를 사용하거나 <script setup>을 사용하지 않는 경우, 참조된 인스턴스는 자식 컴포넌트의 this와 동일하다.
      즉, 부모 컴포넌트는 자식 컴포넌트의 모든 속성과 메서드에 대한 접근 권한을 갖는다.
      이렇게 하면 상하위(부모 자식)간에 밀접하게 결합한 구현 세부 정보를 쉽게 만들 수 있으므로, 컴포넌트 참조는 반드시 필요할 때만 사용해야 한다.
      대부분의 경우 우선적으로 표준 props를 사용하여 상하위 상호 작용을 구현하고 인터페이스를 내보내야 한다.

      여기서 예외는 <script setup>을 사용하는 컴포넌트가 기본적으로 비공개라는 점이다.
      <script setup>을 사용하는 자식 컴포넌트를 부모 컴포넌트에서 참조하려는 경우, 자식 컴포넌트가 defineExpose 컴파일러 메크로를 사용하여
      선택한 인터페이스를 노출하지 않는 한 그 무엇에도 접근할 수 없다.(역자주: 컴파일러 매크로이기 때문에 개발 환경 설정에 따라 lint에러나 경고가 나올 수 있다.)

        <script setup>
        import { ref, defineExpose } from 'vue'

        const a = 1
        const b = ref(2)

        // 컴파일러 매크로, 예를 들어 defineExpose는 import할 필요가 없다.
        defineExpose({
          a,
          b
        })
        </script>

      상위에서 템플릿 참조를 통해 이 컴포넌트의 인스턴스를 가져오면, 검색된 인스턴스는
      { a: number, b: number }와 같다. (일반 인스턴스에서처럼 ref는 자동으로 래핑 해제됨)

  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    요약

      템플릿 내에서 DOM 요소에 접근하고 조작하기 위해 ref라는 기능을 제공한다.
      ref 는 템플릿에서 직접적인 DOM 조작이나 데이터에 접근이 필요한 경우에 사용된다.
      이는 주로 템플릿에서 직접 DOM에 접근해야 하는 경우나 부모-자식 간 통신이 필요한 경우에 유용하다.

      1. 템플릿 내에서 선언
        <template>
          <div>
            //ref를 사용하여 myElement라는 이름으로 DOM 요소에 참조 생성
            <div ref="myElement">Hello, Ref!</div>

            //버튼 클릭 시, 참조한 DOM 요소에 스타일을 변경하는 메서드 호출
            <button @click="changeStyle">Change Style</button>
          </div>
        </template>

        <script>
        export default {
          methods: {
            // ref로 참조한 DOM 요소에 접근하여 스타일 변경
            changeStyle() {
              this.$refs.myElement.style.color = 'blue';
            },
          },
        };
        </script>
      
      2. 동적인 참조 생성
        <template>
          <div>
            //동적으로 ref를 사용하여 생성된 DOM 요소에 참조 생성
            <div v-for="item in items" :key="item.id" :ref="item.id">{{ item.name }}</div>

            버튼 클릭 시, 동적으로 생성된 DOM 요소에 스타일을 변경하는 메서드 호출
            <button @click="changeDynamicStyle">Change Dynamic Style</button>
          </div>
        </template>

        <script>
        export default {
          data() {
            return {
              items: [
                { id: 1, name: 'Item 1' },
                { id: 2, name: 'Item 2' },
                { id: 3, name: 'Item 3' },
              ],
            };
          },
          methods: {
            // 동적으로 생성된 ref로 참조한 DOM 요소에 접근하여 스타일 변경
            changeDynamicStyle() {
              this.items.forEach((item) => {
                this.$refs[item.id][0].style.color = 'green';
              });
            },
          },
        };
        </script>

      특징
        1. 반응성
          - ref를 사용하면 참조한 DOM 요소는 Vue의 반응성 시스템과 통합되어 자동으로 리렌더링된다.

        2. 동적 참조
          - v-for와 함께 사용하여 동적으로 여러 개의 요소에 참조를 생성할 수 있다.

      사용되는 경우
        1. 직접적인 DOM 조작이 필요한 경우
          - 템플릿에서 직접 DOM에 접근하여 조작해야 하는 상황에 ref를 사용한다.

        2. 동적인 참조가 필요한 경우
          - v-for와 함께 사용하여 동적으로 생성되는 여러 요소에 참조가 필요한 경우에 ref를 활용할 수 있다.

        3. Vue의 반응성 시스템과 통합이 필요한 경우
          - ref를 사용하면 참조한 DOM요소가 Vue의 반응성 시스템과 통합되어 값이 변경될 때마다 자동으로 리렌더링된다.

        주의할 점은 가능하면 ref를 사용하여 직접전인 DOM 조작보다는 Vue의 데이터 바인딩 및 컴포넌트 통신 방식을 활용하는 것이 좋다.
        하지만 특정 상황에서 필요할 때 ref를 적절히 활용하면 유용하다.

  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    템플릿 ref를 활용하여 유용한 상황

    1. 외부 라이브러리와 통합
      - Vue 컴포넌트가 외부 라이브러리와 상호작용해야 할 때 ref를 사용할 수 있다.
        외부 라이브러리는 일반적으로 DOM요소에 직접적으로 접근하는 방식을 사용하므로, 해당 요소에 ref를 사용하여 Vue 컴포넌트와 통합할 수 있다.

    2. 애니메이션 및 트랜지션 제어
      - 특정 요소에 대한 애니메이션 또는 트렌지션을 제어할 때 ref를 사용할 수 있다.
        ref를 통해 해당 DOM 요소에 직접적으로 접근하여 애니메이션 클래스를 추가하거나 스타일을 변경할 수 있다.

    3. 외부 이벤트 처리
      - 외브 이벤트가 발생할 때 해당 이벤트에 대한 처리가 필요한 경우 ref를 사용하여 이벤트 리스너를 추가할 수 있다.
        예를 들어, 외부 라이브러리에서 특정 이벤트를 발생시켰을 때 해당 이벤트를 감지하고 처리하는데 ref를 사용할 수 있다.

    4. 플러그인과의 통합
      - 플러그인이나 외부 모듈과의 통합이 필요한 경우 ref를 사용하여 컴포넌트 내의 특정 DOM 요소에 접근할 수 있다.
        이를 통해 플러그인과 컴포넌트 간의 연동이 가능해진다.

    5. 포커스 제어
      - 특정 입력 필드나 다른 포커스가 필요한 요소에 ref를 사용하여 포커스를 직접 제어할 수 있다.
        이는 사용자 경험을 향상시키는 데에 도움이 될 수 있다.

    6. 기타 특정한 DOM 조작
      - 특정한 상황에서 데이터 바인딩이나 컴포넌트 통신 방식으로는 해결하기 어려운 특정한 DOM 조작이 필요한 경우에 ref를 사용할 수 있다.

    단, ref를 사용할 때는 Vue의 반응성 시스템을 우회하는 것이기 때문에 주의가 필요하다.
    가능한 데이터 바인딩이나 컴포넌트 통신 방식을 우선적으로 고려하고, ref를 사용하는 것은 특별한 상황에서 필요한 경우에 한정하는 것이 좋다.




-->
<script>
export default {
	setup() {
		return {};
	},
};
</script>

<style lang="scss" scoped></style>
